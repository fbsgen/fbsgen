//========================================================================
//Copyright 2014 David Yu
//------------------------------------------------------------------------
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at 
//http://www.apache.org/licenses/LICENSE-2.0
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//========================================================================

parser grammar ProtoParser;

options {

    // Default language but name it anyway
    //
    language  = Java;

    // Produce an AST
    //
    output    = AST;

    // Use a superclass to implement all helper
    // methods, instance variables and overrides
    // of ANTLR default methods, such as error
    // handling.
    //
    superClass = AbstractParser;

    // Use the vocabulary generated by the accompanying
    // lexer. Maven knows how to work out the relationship
    // between the lexer and parser and will build the 
    // lexer before the parser. It will also rebuild the
    // parser if the lexer changes.
    //
    tokenVocab = ProtoLexer;
}

// Some imaginary tokens for tree rewrites
//

// What package should the generated source exist in?
//
@header {
    package com.dyuproject.fbsgen.parser;
}

parse [Proto proto]
    :   (statement[proto])+ EOF! {
            proto.checkAnnotations();
            proto.postParse();
        }
    ;
    
statement [Proto proto]
    :   header_syntax[proto]
    |   header_package[proto]
    |   header_import[proto]
    |   message_block[proto, null]
    |   enum_block[proto, null]
    //|   extend_block[proto, null]
    |   service_block[proto, null]
    |   annotation_entry[proto]
    |   comment_entry[proto]
    |   option_entry[proto, proto]
    ;

// some keywords that might possibly be used as a variable
var_reserved
    :   TO | PKG | SYNTAX | IMPORT | OPTION | MESSAGE | SERVICE | ENUM | 
        REQUIRED | OPTIONAL | REPEATED | 
        //EXTENSIONS | EXTEND | GROUP | 
        RPC | RETURNS | 
        INT8 | INT16 | INT32 | INT64 | 
        UINT8 | UINT16 | UINT32 | UINT64 | 
        FLOAT | DOUBLE | BOOL | 
        STRING | BYTES | DEFAULT | MAX | VOID
    ; 

var
    :   ID | var_reserved
    ;

var_full
    :   FULL_ID | var
    ;

comment_entry [Proto proto]
    :   DOC_COMMENT { proto.addComment($DOC_COMMENT.text); }
    ;

annotation_entry [Proto proto]
@init {
    Annotation annotation = null;
}
    :   AT var { annotation = new Annotation($var.text, proto); }
        (LEFTPAREN 
        annotation_keyval[proto, annotation] (COMMA annotation_keyval[proto, annotation])* 
        RIGHTPAREN)? {
            proto.add(annotation);
        }
    ;

list_val [List<Object> list]
@init {
    List<Object> sub = null;
    Map<String, Object> map = null;
}
    :   (
            (
                LEFTSQUARE {
                    list.add((sub = new ArrayList<Object>()));
                }
                list_val[sub] (COMMA list_val[sub])* 
                RIGHTSQUARE
            )
            |
            (
                LEFTCURLY {
                    list.add((map = new java.util.LinkedHashMap<String, Object>()));
                }
                map_val[map] (COMMA map_val[map])* 
                RIGHTCURLY
            )
            |   NUMFLOAT { list.add(Float.valueOf($NUMFLOAT.text)); }
            |   NUMINT { list.add(parseNumber($NUMINT.text)); }
            |   NUMDOUBLE { list.add(Double.valueOf($NUMDOUBLE.text)); }
            |   TRUE { list.add(Boolean.TRUE); }
            |   FALSE { list.add(Boolean.FALSE); }
            |   STRING_LITERAL { list.add(getStringFromStringLiteral($STRING_LITERAL.text)); }
        )
    ;

map_val [Map<String, Object> map]
@init {
    Map<String, Object> sub = null;
    List<Object> list = null;
}
    :   k=var_full COLON (
            (
                LEFTCURLY {
                    map.put($k.text, (sub = new java.util.LinkedHashMap<String, Object>()));
                }
                map_val[sub] (COMMA map_val[sub])* 
                RIGHTCURLY
            )
            |
            (
                LEFTSQUARE {
                    map.put($k.text, (list = new ArrayList<Object>()));
                }
                list_val[list] (COMMA list_val[list])* 
                RIGHTSQUARE
            )
            |   NUMFLOAT { map.put($k.text, Float.valueOf($NUMFLOAT.text)); }
            |   NUMINT { map.put($k.text, parseNumber($NUMINT.text)); }
            |   NUMDOUBLE { map.put($k.text, Double.valueOf($NUMDOUBLE.text)); }
            |   TRUE { map.put($k.text, Boolean.TRUE); }
            |   FALSE { map.put($k.text, Boolean.FALSE); }
            |   STRING_LITERAL { map.put($k.text, getStringFromStringLiteral($STRING_LITERAL.text)); }
        )
    ;

annotation_keyval [Proto proto, Annotation annotation]
@init {
    Map<String, Object> map = null;
    List<Object> list = null;
}
    :   k=var_full (ASSIGN|COLON) (
            (
                LEFTCURLY {
                    annotation.put($k.text, (map = new java.util.LinkedHashMap<String, Object>()));
                }
                map_val[map] (COMMA map_val[map])* 
                RIGHTCURLY
            )
            |
            (
                LEFTSQUARE {
                    annotation.put($k.text, (list = new ArrayList<Object>()));
                }
                list_val[list] (COMMA list_val[list])* 
                RIGHTSQUARE
            )
            |   vr=var_reserved { annotation.put($k.text, $vr.text); }
            |   ID { annotation.putRef($k.text, $ID.text); }
            |   fid=FULL_ID { annotation.putRef($k.text, $fid.text); }
            |   NUMFLOAT { annotation.put($k.text, Float.valueOf($NUMFLOAT.text)); }
            |   NUMINT { annotation.put($k.text, parseNumber($NUMINT.text)); }
            |   NUMDOUBLE { annotation.put($k.text, Double.valueOf($NUMDOUBLE.text)); }
            |   TRUE { annotation.put($k.text, Boolean.TRUE); }
            |   FALSE { annotation.put($k.text, Boolean.FALSE); }
            |   STRING_LITERAL { annotation.put($k.text, getStringFromStringLiteral($STRING_LITERAL.text)); }
        )
    ;

header_syntax [Proto proto]
    :   SYNTAX ASSIGN STRING_LITERAL SEMICOLON! {
            if (!"proto2".equals(getStringFromStringLiteral($STRING_LITERAL.text))) {
                throw err(proto, "Syntax isn't proto2: '" +
                        getStringFromStringLiteral($STRING_LITERAL.text)+"'");
            }
            
            proto.checkAnnotations();
        }
    ;

header_package [Proto proto]
@init {
    String value = null;
}
    :   PKG (FULL_ID { value = $FULL_ID.text; } | var { value = $var.text; }) SEMICOLON! {
            if (proto.getPackageName() != null)
                throw err(proto, "Multiple package definitions.");
            
            proto.setPackageName(value);
            
            proto.checkAnnotations();
        }
    ;
    
header_import [Proto proto]
    :   IMPORT STRING_LITERAL SEMICOLON! {
            proto.importProto(getStringFromStringLiteral($STRING_LITERAL.text));
            
            proto.checkAnnotations();
        }
    ;

option_entry [Proto proto, HasOptions ho]
@init {
    Map<String, Object> map = null;
    List<Object> list = null;
}
    :   OPTION LEFTPAREN? k=var_full RIGHTPAREN? ASSIGN (
            (
                LEFTCURLY {
                    putExtraOptionTo(ho, $k.text, (map = new java.util.LinkedHashMap<String, Object>()), proto);
                }
                map_val[map] (COMMA map_val[map])* 
                RIGHTCURLY
            )
            |
            (
                LEFTSQUARE {
                    putExtraOptionTo(ho, $k.text, (list = new ArrayList<Object>()), proto);
                }
                list_val[list] (COMMA list_val[list])* 
                RIGHTSQUARE
            )
            |   vr=var_reserved { putExtraOptionTo(ho, $k.text, $vr.text, proto); }
            |   id=ID { putStandardOptionTo(ho, $k.text, $id.text, proto); }
            |   fid=FULL_ID { putStandardOptionTo(ho, $k.text, $fid.text, proto); }
            |   NUMFLOAT { putExtraOptionTo(ho, $k.text, Float.valueOf($NUMFLOAT.text), proto); }
            |   NUMINT { putExtraOptionTo(ho, $k.text, parseNumber($NUMINT.text), proto); }
            |   NUMDOUBLE { putExtraOptionTo(ho, $k.text, Double.valueOf($NUMDOUBLE.text), proto); }
            |   TRUE { putExtraOptionTo(ho, $k.text, Boolean.TRUE, proto); }
            |   FALSE { putExtraOptionTo(ho, $k.text, Boolean.FALSE, proto); }
            |   STRING_LITERAL { putExtraOptionTo(ho, $k.text, getStringFromStringLiteral($STRING_LITERAL.text), proto); }
        ) SEMICOLON! {
            proto.checkAnnotations();
        }
    ;
    
message_block [Proto proto, Message parent]
@init {
    Message message = null;
}
    :   MESSAGE ID { 
            message = new Message($ID.text, parent, proto);
            proto.addAnnotationsTo(message);
        } 
        LEFTCURLY (message_body[proto, message])* RIGHTCURLY {
            proto.checkAnnotations();
        }
    ;

message_body [Proto proto, Message message]
    :   message_block[proto, message]
    |   message_field[proto, message]
    |   enum_block[proto, message]
    |   service_block[proto, message]
    //|   extend_block[proto, message]
    //|   extensions_range[proto, message]
    |   annotation_entry[proto]
    |   comment_entry[proto]
    |   option_entry[proto, message]
    ;
    
//extensions_range [Proto proto, Message message]
//@init {
//  int first = -1;
//  int last = -1;
//}
//    :   EXTENSIONS f=NUMINT { first = Integer.parseInt($f.text); last = first;}
//        ( TO ( l=NUMINT { last = Integer.parseInt($l.text); } | MAX {last = 536870911; } ) )?
//        SEMICOLON! {
//            message.defineExtensionRange(first, last);
//        }
//    ;
    
message_field [Proto proto, HasFields message]
@init {
    Field.Modifier modifier = null;
    FieldHolder fieldHolder = null;
}
    :   (OPTIONAL { modifier = Field.Modifier.OPTIONAL;  } 
        |   REQUIRED { modifier = Field.Modifier.REQUIRED; } 
        |   REPEATED { modifier = Field.Modifier.REPEATED; }) {
            fieldHolder = new FieldHolder();
        }
        field_type[proto, message, fieldHolder] 
        var ASSIGN NUMINT {
            if (fieldHolder.field != null) {
                fieldHolder.field.modifier = modifier;
                fieldHolder.field.name = $var.text;
                fieldHolder.field.number = Integer.parseInt($NUMINT.text);
                message.addField(fieldHolder.field);
            }
        } 
        (field_options[proto, message, fieldHolder.field])? {
            if (fieldHolder.field != null) {
                proto.addAnnotationsTo(fieldHolder.field, message.getEnclosingNamespace());
                fieldHolder.field.resolvePbType();
            }
        }
        (SEMICOLON! | ignore_block)
    ;
    
field_type [Proto proto, HasFields message, FieldHolder fieldHolder]
    :   BOOL { fieldHolder.setField(new Field.Bool()); }
    |   INT8 { fieldHolder.setField(new Field.Int8()); }
    |   UINT8 { fieldHolder.setField(new Field.UInt8()); }
    |   INT16 { fieldHolder.setField(new Field.Int16()); }
    |   UINT16 { fieldHolder.setField(new Field.UInt16()); }
    |   INT32 { fieldHolder.setField(new Field.Int32()); }
    |   UINT32 { fieldHolder.setField(new Field.UInt32()); }
    |   INT64 { fieldHolder.setField(new Field.Int64()); }
    |   UINT64 { fieldHolder.setField(new Field.UInt64()); }
    |   FLOAT { fieldHolder.setField(new Field.Float()); }
    |   DOUBLE { fieldHolder.setField(new Field.Double()); }
    |   STRING { fieldHolder.setField(new Field.String()); }
    |   BYTES { fieldHolder.setField(new Field.Bytes()); }
    //|   GROUP {
    //        String suffix = proto.getFile() == null ? "" : " of " + proto.getFile().getName();
    //        warn(proto, "'group' not supported @ line " + $GROUP.line + suffix);
    //    }
    |   FULL_ID {
            String fullType = $FULL_ID.text;
            int lastDot = fullType.lastIndexOf('.');
            String packageName = fullType.substring(0, lastDot);
            String type = fullType.substring(lastDot+1);
            fieldHolder.setField(new Field.Reference(packageName, type, message));
        }
    |   ID { 
            String type = $ID.text;
            fieldHolder.setField(new Field.Reference(null, type, message));
        }
    ;
    
field_options [Proto proto, HasFields message, Field field]
    :   LEFTSQUARE field_options_keyval[proto, message, field, true] 
        (COMMA field_options_keyval[proto, message, field, true])* RIGHTSQUARE
    ;
    
field_options_keyval [Proto proto, HasFields message, Field field, boolean checkDefault]
@init {
    Map<String, Object> map = null;
    List<Object> list = null;
}
    :   key=var_full ASSIGN (
    (
        LEFTCURLY {
            field.putExtraOption($key.text, (map = new java.util.LinkedHashMap<String, Object>()));
        }
        map_val[map] (COMMA map_val[map])* 
        RIGHTCURLY
    )
    |
    (
        LEFTSQUARE {
            field.putExtraOption($key.text, (list = new ArrayList<Object>()));
        }
        list_val[list] (COMMA list_val[list])* 
        RIGHTSQUARE
    )
    |   vr=var_reserved {
            field.putExtraOption($key.text, $vr.text);
        } 
    |   STRING_LITERAL {
            if (!"default".equals($key.text)) {
                field.putExtraOption($key.text, getStringFromStringLiteral($STRING_LITERAL.text));
            } else if (checkDefault) {
                if (field.defaultValue != null || field.modifier == Field.Modifier.REPEATED)
                    throw err(field, " can only have a single default value", proto);
                
                if (field instanceof Field.String || field instanceof Field.Bytes)
                    field.defaultValue = getStringFromStringLiteral($STRING_LITERAL.text);
                else
                    throw err(field, " has an invalid string default value", proto);
                
                // not putting the 'default' key in the field options
                //field.putExtraOption($key.text, field.defaultValue);
            } else {
                warnDefaultKeyword(field, proto);
            }
        }
    |   NUMFLOAT {
            if (!"default".equals($key.text)) {
                field.putExtraOption($key.text, Float.valueOf($NUMFLOAT.text));
            } else if (checkDefault) {
                if (field.defaultValue != null || field.modifier == Field.Modifier.REPEATED)
                    throw err(field, " can only have a single default value", proto);
                
                if (field instanceof Field.Float)
                    field.defaultValue = Float.valueOf($NUMFLOAT.text);
                else if (field instanceof Field.Double) 
                    field.defaultValue = Double.valueOf($NUMFLOAT.text);
                else
                    throw err(field, " has an invalid float default value", proto);
                
                // not putting the 'default' key in the field options
                //field.putExtraOption($key.text, field.defaultValue);
            } else {
                warnDefaultKeyword(field, proto);
            }
        } 
    |   NUMINT {
            if (!"default".equals($key.text)) {
                field.putExtraOption($key.text, parseNumber($NUMINT.text));
            } else if (checkDefault) {
                if (field.defaultValue != null || field.modifier == Field.Modifier.REPEATED)
                    throw err(field, " can only have a single default value", proto);
                
                if (field instanceof Field.Number) {
                    if (field instanceof Field.Float)
                        field.defaultValue = Float.valueOf($NUMINT.text);
                    else if (field instanceof Field.Double) 
                        field.defaultValue = Double.valueOf($NUMINT.text);
                    else if (field.getClass().getSimpleName().endsWith("64"))
                        field.defaultValue = validate(proto, field, Long.parseLong($NUMINT.text));
                    else
                        field.defaultValue = validate(proto, field, Integer.parseInt($NUMINT.text));
                }
                else
                    throw err(field, " has an invalid numeric default value", proto);
                
                // not putting the 'default' key in the field options
                //field.putExtraOption($key.text, field.defaultValue);
            } else {
                warnDefaultKeyword(field, proto);
            }
        }
    |   NUMDOUBLE {
            if (!"default".equals($key.text)) {
                field.putExtraOption($key.text, Double.valueOf($NUMDOUBLE.text));
            } else if (checkDefault) {
                if (field.defaultValue != null || field.modifier == Field.Modifier.REPEATED)
                    throw err(field, " can only have a single default value", proto);

                if (field instanceof Field.Float)
                    field.defaultValue = Float.valueOf($NUMDOUBLE.text);
                else if (field instanceof Field.Double) 
                    field.defaultValue = Double.valueOf($NUMDOUBLE.text);
                else
                    throw err(field, " has an invalid double default value", proto);
                
                // not putting the 'default' key in the field options
                //field.putExtraOption($key.text, field.defaultValue);
            } else {
                warnDefaultKeyword(field, proto);
            }
        }
    |   HEX {
            if (!"default".equals($key.text)) {
                field.putExtraOption($key.text, Long.valueOf(TextFormat.parseLong(proto, field, $HEX.text, true)));
            } else if (checkDefault) {
                if (field.defaultValue != null || field.modifier == Field.Modifier.REPEATED)
                    throw err(field, " can only have a single default value", proto);
                
                if (field instanceof Field.Number) {
                    if (field instanceof Field.Float)
                        field.defaultValue = new Float(Long.decode($HEX.text).floatValue());
                    else if (field instanceof Field.Double) 
                        field.defaultValue = new Double(Long.decode($HEX.text).doubleValue());
                    else if (field.getClass().getSimpleName().endsWith("64")) {
                        field.defaultValue = Long.valueOf(validate(proto, field, TextFormat.parseLong(proto, field, $HEX.text, 
                                field.getClass().getSimpleName().charAt(0) != 'U')));
                    } else {
                        field.defaultValue = Integer.valueOf(validate(proto, field, TextFormat.parseInt(proto, field, $HEX.text, 
                                field.getClass().getSimpleName().charAt(0) != 'U')));
                    }
                }
                else if (field instanceof Field.Bytes) {
                    field.defaultValue = $HEX.text;
                }
                else
                    throw err(field, " has an invalid numeric default value", proto);
                
                // not putting the 'default' key in the field options
                //field.putExtraOption($key.text, field.defaultValue);
            } else {
                warnDefaultKeyword(field, proto);
            }
        }
    |   OCTAL {
            if (!"default".equals($key.text)) {
                field.putExtraOption($key.text, Integer.valueOf(TextFormat.parseInt(proto, field, $OCTAL.text, true)));
            } else if (checkDefault) {
                if (field.defaultValue != null || field.modifier == Field.Modifier.REPEATED)
                    throw err(field, " can only have a single default value", proto);
                
                if (field instanceof Field.Number) {
                    if (field instanceof Field.Float)
                        field.defaultValue = new Float(Long.decode($OCTAL.text).floatValue());
                    else if (field instanceof Field.Double) 
                        field.defaultValue = new Double(Long.decode($OCTAL.text).doubleValue());
                    else if (field.getClass().getSimpleName().endsWith("64")) {
                        field.defaultValue = Long.valueOf(validate(proto, field, TextFormat.parseLong(proto, field, $OCTAL.text, 
                                field.getClass().getSimpleName().charAt(0) != 'U')));
                    } else {
                        field.defaultValue = Integer.valueOf(validate(proto, field, TextFormat.parseInt(proto, field, $OCTAL.text, 
                                field.getClass().getSimpleName().charAt(0) != 'U')));
                    }
                }
                else
                    throw err(field, " has an invalid numeric default value", proto);
                
                // not putting the 'default' key in the field options
                //field.putExtraOption($key.text, field.defaultValue);
            } else {
                warnDefaultKeyword(field, proto);
            }
        }
    |   TRUE {
            if (!"default".equals($key.text)) {
                field.putExtraOption($key.text, Boolean.TRUE);
            } else if (checkDefault) {
                if (field.defaultValue != null || field.modifier == Field.Modifier.REPEATED)
                    throw err(field, " can only have a single default value", proto);
                
                if (field instanceof Field.Bool)
                    field.defaultValue = Boolean.TRUE;
                else
                    throw err(field, " has an invalid bool default value", proto);
                
                // not putting the 'default' key in the field options
            } else {
                warnDefaultKeyword(field, proto);
            }
        }    
    |   FALSE {
            if (!"default".equals($key.text)) {
                field.putExtraOption($key.text, Boolean.FALSE);
            } else if (checkDefault) {
                if (field.defaultValue != null || field.modifier == Field.Modifier.REPEATED)
                    throw err(field, " can only have a single default value", proto);
                
                if (field instanceof Field.Bool)
                    field.defaultValue = Boolean.FALSE;
                else
                    throw err(field, " has an invalid bool default value", proto);
                
                // not putting the 'default' key in the field options
            } else {
                warnDefaultKeyword(field, proto);
            }
        }
    |   val=ID {
            if (!"default".equals($key.text)) {
                field.putStandardOption($key.text, $val.text);
            } else if (checkDefault) {
                if (field.defaultValue != null || field.modifier == Field.Modifier.REPEATED)
                    throw err(field, " can only have a single default value", proto);
                
                String refName = $val.text;
                if (field instanceof Field.Reference)
                    field.defaultValue = refName;
                else if (field instanceof Field.Float) {
                    if ("inf".equals(refName)) {
                        field.defaultValue = Float.POSITIVE_INFINITY;
                        field.defaultValueConstant = "Float.POSITIVE_INFINITY";
                    }
                    else if ("nan".equals(refName)) {
                        field.defaultValue = Float.NaN;
                        field.defaultValueConstant = "Float.NaN";
                    }
                    else
                        throw err(field, " has an invalid default value", proto);
                }
                else if (field instanceof Field.Double) {
                    if ("inf".equals(refName)) {
                        field.defaultValue = Double.POSITIVE_INFINITY;
                        field.defaultValueConstant = "Double.POSITIVE_INFINITY";
                    }
                    else if ("nan".equals(refName)) {
                        field.defaultValue = Double.NaN;
                        field.defaultValueConstant = "Double.NaN";
                    }
                    else
                        throw err(field, " has an invalid default value", proto);
                }
                
                // not putting the 'default' key in the field options
            }
            else {
                warnDefaultKeyword(field, proto);
            }
        }
    |   FULL_ID {
            if (!"default".equals($key.text)) {
                field.putStandardOption($key.text, $FULL_ID.text);
            } else {
                warnDefaultKeyword(field, proto);
            }
        }
    |   EXP {
            if (!"default".equals($key.text)) {
                field.putExtraOption($key.text, $EXP.text);
            } else if (checkDefault) {
                if (field.defaultValue != null || field.modifier == Field.Modifier.REPEATED)
                    throw err(field, " can only have a single default value", proto);
                
                if (field instanceof Field.Float)
                    field.defaultValue = Float.valueOf($EXP.text);
                else if (field instanceof Field.Double)
                    field.defaultValue = Double.valueOf($EXP.text);
                else
                    throw err(field, " has an invalid float default value", proto);
                
                // not putting the 'default' key in the field options
            } else {
                warnDefaultKeyword(field, proto);
            }
        }
    |   signed_constant[proto, message, field, $key.text, checkDefault] {
            // handled by signed_constant
            if (!"default".equals($key.text)) {
                field.putExtraOption($key.text, $signed_constant.text);
            } else if (!checkDefault) {
                warnDefaultKeyword(field, proto);
            }
        }
        )
    ;
    
signed_constant [Proto proto, HasFields message, Field field, String key, boolean checkDefault]
    :   MINUS ID {
            if (checkDefault && "default".equals(key)) {
                if (field.defaultValue != null || field.modifier == Field.Modifier.REPEATED)
                    throw err(field, " can only have a single default value", proto);
                
                String refName = $ID.text;
                if (field instanceof Field.Float) {
                    if ("inf".equals(refName)) {
                        field.defaultValue = Float.NEGATIVE_INFINITY;
                        field.defaultValueConstant = "Float.NEGATIVE_INFINITY";
                    }
                    else
                        throw err(field, " has an invalid float default value", proto);
                }
                else if (field instanceof Field.Double) {
                    if ("inf".equals(refName)) {
                        field.defaultValue = Double.NEGATIVE_INFINITY;
                        field.defaultValueConstant = "Double.NEGATIVE_INFINITY";
                    }
                    else
                        throw err(field, " has an invalid double default value", proto);
                }   
                else
                    throw err(field, " has an invalid default value: " + refName, proto);
            }
        }
    ;
    
enum_block [Proto proto, Message message]
@init {
    EnumGroup enumGroup = null;
}
    :   ENUM ID { 
            enumGroup = new EnumGroup($ID.text, message, proto);
            proto.addAnnotationsTo(enumGroup);
        } 
        LEFTCURLY (enum_body[proto, message, enumGroup])* RIGHTCURLY {
            proto.checkAnnotations();
        } (SEMICOLON?)!
    ;
    
enum_body [Proto proto, Message message, EnumGroup enumGroup]
    :   enum_field[proto, message, enumGroup]
    |   annotation_entry[proto]
    |   comment_entry[proto]
    |   option_entry[proto, enumGroup]
    ;

enum_field [Proto proto, Message message, EnumGroup enumGroup]
@init {
    EnumGroup.Value v = null;
}
    :   ID ASSIGN NUMINT {
            v = new EnumGroup.Value($ID.text, Integer.parseInt($NUMINT.text), enumGroup);
            proto.addAnnotationsTo(v);
        } (enum_options[proto, enumGroup, v])? SEMICOLON! 
    ;

enum_options [Proto proto, EnumGroup enumGroup, EnumGroup.Value v]
    :   LEFTSQUARE field_options_keyval[proto, null, v.field, false] 
        (COMMA field_options_keyval[proto, null, v.field, false])* RIGHTSQUARE
    ;
    
service_block [Proto proto, Message message]
@init {
    Service service = null;
}
    :   SERVICE ID { 
            service = new Service($ID.text, message, proto); 
            proto.addAnnotationsTo(service);
        } LEFTCURLY
        (service_body[proto, service])+ RIGHTCURLY (SEMICOLON?)! {
            if (service.rpcMethods.isEmpty())
                throw err(service, " must declare at least one rpc", proto);
                
            proto.checkAnnotations();
        }
    ;
    
service_body [Proto proto, Service service]
    :   rpc_block[proto, service]
    |   annotation_entry[proto]
    |   comment_entry[proto]
    |   option_entry[proto, service]
    ;
    
rpc_block [Proto proto, Service service]
@init {
    String argName = null, argPackage = null, retName = null, retPackage = null;
    Service.RpcMethod rm = null;
}
    :   RPC n=ID LEFTPAREN (ap=FULL_ID {  
            String argFull = $ap.text;
            int lastDot = argFull.lastIndexOf('.');
            argPackage = argFull.substring(0, lastDot); 
            argName = argFull.substring(lastDot+1);
        } | a=(VOID|ID) { argName = $a.text; }) RIGHTPAREN 
        RETURNS LEFTPAREN (rp=FULL_ID {  
            String retFull = $rp.text;
            int lastDot = retFull.lastIndexOf('.');
            retPackage = retFull.substring(0, lastDot); 
            retName = retFull.substring(lastDot+1);
        } | r=(VOID|ID) { retName = $r.text; }) RIGHTPAREN {
            rm = service.addRpcMethod($n.text, argName, argPackage, retName, retPackage);
            proto.addAnnotationsTo(rm);
        } rpc_body_block[proto, rm]? SEMICOLON!
    ;
    
rpc_body_block [Proto proto, Service.RpcMethod rm]
    :   LEFTCURLY option_entry[proto, rm]* RIGHTCURLY {
            proto.checkAnnotations();
        }
    ;
    
//extend_block [Proto proto, Message parent]
//@init {
//    Extension extension = null;
//}
//    :   EXTEND (
//        FULL_ID {
//            String fullType = $FULL_ID.text;
//            int lastDot = fullType.lastIndexOf('.');
//            String packageName = fullType.substring(0, lastDot); 
//            String type = fullType.substring(lastDot+1);
//            extension = new Extension(proto, parent, packageName, type);
//        } | ID { extension = new Extension(proto, parent, null, $ID.text); } ) {
//            if (parent == null)
//                proto.addExtension(extension);
//            else
//                parent.addNestedExtension(extension);
//                
//            proto.addAnnotationsTo(extension);
//        }
//        LEFTCURLY (extend_body[proto, extension])* RIGHTCURLY {
//            proto.checkAnnotations();
//                
//        } (SEMICOLON?)!
//    ;
    
//extend_body [Proto proto, Extension extension]
//    :   message_field[proto, extension]
//    |   annotation_entry[proto]
//    |   comment_entry[proto]
//    ;
    
ignore_block
    :   LEFTCURLY ignore_block_body* RIGHTCURLY
    ;
    
ignore_block_body
    :   (LEFTCURLY)=> ignore_block
    |   ~RIGHTCURLY
    ;
    
